<script>
  document.addEventListener('DOMContentLoaded', () => {
    const chatMessages = document.getElementById('chat-messages');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const restartButton = document.getElementById('restart-chat');
    const modelSelector = document.getElementById('model-selector');

    let messageHistory = [{ role: 'assistant', content: "Welcome to ServeSmartAI, let's get started..." }];

    // Utility
    const addSpacer = () => { if (!chatMessages.querySelector('.spacer')) chatMessages.appendChild(Object.assign(document.createElement('div'), { className: 'spacer' })); };
    const removeSpacer = () => { const s = chatMessages.querySelector('.spacer'); if (s) s.remove(); };
    const scrollToBottom = (instant = false) => chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: instant ? 'instant' : 'smooth' });
    const createCopyButton = () => {
      const b = document.createElement('button');
      b.className = 'copy-button';
      b.title = 'Copy message';
      b.onclick = () => {
        const el = b.closest('.message')?.querySelector('.message-content');
        if (!el) return;
        navigator.clipboard.writeText(el.textContent || el.innerText);
        const n = document.getElementById('copy-notification');
        if (n) { n.style.opacity = '1'; setTimeout(() => n.style.opacity = '0', 2000); }
      };
      b.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
      return b;
    };
    const addBotBubble = (text, placeholderRefs) => {
      const content = document.createElement('div');
      content.className = 'message-content';
      content.textContent = text.trim();
      const copyBtn = createCopyButton();
      if (placeholderRefs) {
        const { messageDiv } = placeholderRefs;
        messageDiv.innerHTML = '';
        messageDiv.appendChild(content);
        messageDiv.appendChild(copyBtn);
      } else {
        removeSpacer();
        const g = document.createElement('div'); g.className = 'message-group';
        const d = document.createElement('div'); d.className = 'message bot-message';
        d.appendChild(content); d.appendChild(copyBtn); g.appendChild(d);
        chatMessages.appendChild(g);
      }
      messageHistory.push({ role: 'assistant', content: text.trim() });
      addSpacer(); scrollToBottom();
    };
    const addUserBubble = (text) => {
      removeSpacer();
      const g = document.createElement('div'); g.className = 'message-group';
      const d = document.createElement('div'); d.className = 'message user-message';
      d.textContent = text; g.appendChild(d); chatMessages.appendChild(g);
      messageHistory.push({ role: 'user', content: text });
      addSpacer(); scrollToBottom();
    };
    const typingPlaceholder = () => {
      removeSpacer();
      const g = document.createElement('div'); g.className = 'message-group';
      const d = document.createElement('div'); d.className = 'message bot-message';
      const dots = document.createElement('div'); dots.className = 'typing-dots';
      for (let i = 0; i < 3; i++) { const dot = document.createElement('span'); dot.className = 'typing-dot'; dots.appendChild(dot); }
      d.appendChild(dots); g.appendChild(d); chatMessages.appendChild(g);
      addSpacer(); scrollToBottom(); return { messageGroup: g, messageDiv: d };
    };

    // Load models from your secure endpoint
    async function loadModels() {
      try {
        const r = await fetch('/api/straico/models');
        const data = await r.json();
        const list = Array.isArray(data?.data) ? data.data : [];
        modelSelector.innerHTML = '';
        list.forEach(m => {
          if (!m?.model) return;
          const opt = document.createElement('option');
          opt.value = m.model;
          opt.textContent = m.name || m.model;
          modelSelector.appendChild(opt);
        });
        // Pick a sensible default if present
        const preferred = 'openai/gpt-4o-mini';
        const match = [...modelSelector.options].find(o => o.value === preferred);
        modelSelector.value = match ? preferred : modelSelector.options[0]?.value;
      } catch {
        // Fallback if listing fails
        ['openai/gpt-4o-mini'].forEach(id => {
          const o = document.createElement('option'); o.value = id; o.textContent = id;
          modelSelector.appendChild(o);
        });
      }
    }

    // Send via your Vercel proxy. Proxy converts messages -> prompt for Straico.
    async function sendToProxy() {
      const placeholder = typingPlaceholder();
      try {
        const r = await fetch('/api/straico/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: modelSelector.value,
            messages: messageHistory,
            stream: false
          })
        });
        const raw = await r.text();
        let data; try { data = JSON.parse(raw); } catch { data = { raw }; }
        if (!r.ok) {
          const msg = data?.response?.error || data?.error || raw;
          addBotBubble(`Sorry, there was an error: ${msg}`, placeholder);
          return;
        }
        const reply =
          data?.choices?.[0]?.message?.content
          || data?.response?.completion?.choices?.[0]?.message?.content
          || data?.response?.text
          || 'No content returned.';
        addBotBubble(reply, placeholder);
      } catch (e) {
        addBotBubble('Network error. Please try again.', placeholder);
      }
    }

    // Events
    sendButton.addEventListener('click', () => {
      const msg = userInput.value.trim();
      if (!msg) return;
      addUserBubble(msg);
      userInput.value = ''; userInput.style.height = '30px';
      sendToProxy();
    });
    userInput.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendButton.click(); }
    });
    restartButton?.addEventListener('click', () => {
      chatMessages.innerHTML = ''; messageHistory = [];
      messageHistory.push({ role: 'assistant', content: "Welcome to ServeSmartAI, let's get started..." });
      addBotBubble("Welcome to ServeSmartAI, let's get started...");
      userInput.value = '';
    });

    // Boot
    addBotBubble("Welcome to ServeSmartAI, let's get started...");
    loadModels();
  });
</script>
