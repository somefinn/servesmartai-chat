<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ServeSmartAI</title>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#0f1115; --bg-2:#0c0f14;
    --panel:#141a22; --surface:#161d27;
    --ink:#e9edf3; --muted:#9aa6b2;
    --ring:#263447; --accent:#6aa6ff; --accent-2:#7b7bff;
    --bubble-user:#1f2735; --bubble-ai:#121923;
    --shadow:0 10px 30px rgba(0,0,0,.35), 0 1px 0 rgba(255,255,255,.02) inset;
  }

  *{ box-sizing:border-box }
  html, body{ height:100%; overflow:hidden }
  body{
    margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:var(--ink);
    background:
      radial-gradient(1400px 900px at 10% -10%, #25324a 0%, transparent 60%),
      radial-gradient(1000px 800px at 110% -10%, #1d2b45 0%, transparent 55%),
      linear-gradient(180deg, var(--bg), var(--bg-2));
  }

/* centre the 3 dots inside the thinking bubble */
.ai.typing{
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  height: 34px;             /* explicit box height */
  padding: 6px 10px;        /* compact */
  line-height: 0;           /* kill baseline shift */
}
.ai.typing .dot{ display:block; vertical-align: middle; }

/* more space so the last bubble never kisses the input */
.messages{
  padding-bottom: 108px;     /* extra room at bottom */
  scroll-padding-bottom: 108px;
}

  .ai.typing .dot{ vertical-align: middle; }

/* slightly larger vertical gap between bubbles */
.bubble{ margin: 10px 0; }

/* kill the old sentence fade so there is no stutter */
.rich .sentence{ animation: none !important; opacity: 1 !important; transform: none !important; }

/* float the chat panel; a gap between header and panel */
.wrap{ row-gap: 18px; }             /* space between header and panel */
@media (min-width: 700px){
  .wrap{ padding-top: 16px; }       /* extra top breathing room on desktop */
}

  /* Layout */
  .wrap{
    height:100dvh; min-height:100svh;
    display:grid; grid-template-rows:auto 1fr auto;
  }
  header{
    backdrop-filter:saturate(150%) blur(8px);
    background:linear-gradient(180deg, rgba(26,34,45,.65), rgba(20,26,34,.65));
    border-bottom:1px solid var(--ring);
    padding:14px clamp(14px,2.5vw,22px);
    display:grid; grid-template-columns:1fr auto; gap:12px; align-items:center;
  }
  .brand{ display:flex; align-items:center; gap:10px }
  .logo{ width:28px; height:28px; border-radius:8px; background:linear-gradient(135deg,var(--accent),var(--accent-2)); box-shadow:0 8px 20px rgba(106,166,255,.35) }
  .title{ margin:0; font-weight:600; font-size:15px; letter-spacing:.2px; color:var(--ink); opacity:.95 }

  .controls{ display:flex; align-items:center; gap:10px }
  .select{
    appearance:none; background:var(--panel); color:var(--ink);
    border:1px solid var(--ring); border-radius:999px;
    padding:10px 40px 10px 14px; font:inherit; font-size:13px; box-shadow:var(--shadow)
  }
  .select:focus{ outline:2px solid var(--accent); outline-offset:2px }
  .chev{ pointer-events:none; margin-left:-34px; width:12px; opacity:.7 }
  .refresh{
    background:var(--panel); color:var(--ink); border:1px solid var(--ring); border-radius:999px;
    width:36px; height:36px; display:grid; place-items:center; margin-left:6px; cursor:pointer; box-shadow:var(--shadow)
  }
  .refresh:hover{ filter:brightness(1.1) }

  .panel{
    max-width:900px; width:100%;
    margin:0 auto;
    height:100%; min-height:0;            /* allow inner scroll */
    display:grid; grid-template-rows:1fr auto;
    border:1px solid var(--ring); background:linear-gradient(180deg,#0f141c,#0e131a);
    border-radius:18px; box-shadow:0 20px 60px rgba(0,0,0,.45); overflow:hidden
  }

  /* Messages area scrolls; page stays still */
  .messages{
    position:relative;
    padding:clamp(14px,2.5vw,20px);
    height:100%; min-height:0; overflow:auto;
  }
  /* top fade mask */
  .messages::before{
    content:""; position:sticky; top:0; left:0; right:0; height:64px;
    background:linear-gradient(180deg, var(--bg), rgba(15,17,21,0));
    pointer-events:none; z-index:2;
  }

  /* Bubbles */
  .bubble{
    display:block;
    width:fit-content;                     /* hug short replies */
    max-width:min(76ch, calc(100% - 32px));
    border-radius:16px; padding:12px 14px; margin:8px 0; line-height:1.6;
    box-shadow:0 1px 0 rgba(255,255,255,.02) inset, 0 10px 24px rgba(0,0,0,.25)
  }
  .user{ background:var(--bubble-user); border:1px solid var(--ring); margin-left:auto }
  .ai{   background:var(--bubble-ai);   border:1px solid var(--ring); margin-right:auto }

  /* tiny centred thinking bubble */
  .ai.typing{
    display:inline-flex; align-items:center; justify-content:center;
    gap:6px; padding:8px 12px; width:fit-content; min-height:0;
  }
  .dot{ width:6px; height:6px; border-radius:50%; background:var(--muted); opacity:.35; animation:blink 1.2s infinite ease-in-out }
  .dot:nth-child(2){ animation-delay:.2s } .dot:nth-child(3){ animation-delay:.4s }
  @keyframes blink{ 0%,80%,100%{opacity:.25; transform:translateY(0)} 40%{opacity:1; transform:translateY(-2px)} }

  /* per-message actions */
  .bubble.ai{ position:relative; padding-bottom:34px }
  .actions{ position:absolute; left:12px; bottom:8px; display:flex; gap:6px; z-index:1 }
  .btn-mini{
    background:#0c1118; color:var(--ink);
    border:1px solid var(--ring); border-radius:8px;
    padding:4px 8px; font-size:11px; cursor:pointer; opacity:.85;
  }
  .btn-mini:hover{ opacity:1 }

  /* Markdown styling */
  .rich h1,.rich h2,.rich h3{ margin:8px 0 6px }
  .rich h1{ font-size:20px } .rich h2{ font-size:18px } .rich h3{ font-size:16px }
  .rich code{ background:#0c1118; border:1px solid var(--ring); padding:2px 6px; border-radius:6px; font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:.95em }
  .rich pre{ background:#0c1118; border:1px solid var(--ring); padding:10px; border-radius:10px; overflow:auto }
  .rich ul{ padding-left:18px; margin:6px 0 } .rich li{ margin:2px 0 }

  /* Composer */
  .composer{ border-top:1px solid var(--ring); display:grid; grid-template-columns:1fr auto; gap:10px; padding:12px; background:linear-gradient(180deg,#0e131a,#0c1118) }
  .input{ background:var(--surface); color:var(--ink); border:1px solid var(--ring); border-radius:12px; padding:14px 16px; font:inherit; font-size:14px; box-shadow:var(--shadow) }
  .input::placeholder{ color:var(--muted) }
  .send{ background:linear-gradient(180deg,var(--accent),#4b86ff); color:#0b1220; border:none; border-radius:12px; padding:12px 18px; font:inherit; font-weight:600; cursor:pointer; box-shadow:0 12px 30px rgba(106,166,255,.35) }
  .send:disabled{ opacity:.6; cursor:default }

  /* Toast */
  .toast{
    position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
    background:rgba(20,26,34,.9); color:var(--ink); border:1px solid var(--ring);
    padding:8px 12px; border-radius:10px; font-size:12px; opacity:0; transition:opacity .2s; z-index:9999
  }
  .toast.show{ opacity:1 }

  /* Footer lower so it never overlaps the input */
  footer{ opacity:.55; font-size:12px; text-align:center; padding:18px 10px 28px }

  @media (max-width:560px){ .panel{ border-radius:0 } .messages{ padding-bottom:8px } }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <h1 class="title">ServeSmartAI</h1>
    </div>

    <div class="controls" title="Choose a model">
      <select id="model" class="select"></select>
      <svg class="chev" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path d="M3 4.5l3 3 3-3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
      </svg>
      <button id="refresh" class="refresh" title="New chat">
        <svg viewBox="0 0 24 24" width="16" height="16" aria-hidden="true">
          <path d="M23 4v6h-6M1 20v-6h6" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>
          <path d="M3.5 9A9 9 0 0 1 18.3 5.6L23 10M1 14l4.7 4.4A9 9 0 0 0 20.5 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>
        </svg>
      </button>
    </div>
  </header>

  <main class="panel">
    <div id="messages" class="messages"></div>
    <div class="composer">
      <input id="prompt" class="input" placeholder="Write your message" autocomplete="off" />
      <button id="send" class="send">Send</button>
    </div>
  </main>

  <footer>Built by ServeSmartAI</footer>
</div>

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
  // Elements
  const modelSel  = document.getElementById('model');
  const messagesEl= document.getElementById('messages');
  const promptEl  = document.getElementById('prompt');
  const sendBtn   = document.getElementById('send');
  const refreshBtn= document.getElementById('refresh');
  const toastEl   = document.getElementById('toast');

  // Conversation memory (raw, no system prompt)
  const history = [];

  // -------- UI helpers --------
  function addUserBubble(text){
    const b = document.createElement('div');
    b.className = 'bubble user';
    b.textContent = text;
    messagesEl.appendChild(b);
    messagesEl.scrollTop = messagesEl.scrollHeight;
    history.push({ role:'user', content:text });
  }

  function addTyping(){
    const b = document.createElement('div');
    b.className = 'bubble ai typing';
    b.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
    messagesEl.appendChild(b);
    messagesEl.scrollTop = messagesEl.scrollHeight;
    return b;
  }

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 1600);
  }

  function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  function mdToHtml(input){
    let s = escapeHtml(input);
    s = s.replace(/```([\s\S]*?)```/g, (_m,c)=>`<pre><code>${c}</code></pre>`);
    s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
    s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    s = s.replace(/(^|[^*])\*(?!\s)([^*]+?)\*(?!\*)/g, '$1<em>$2</em>');
    s = s.replace(/^\s*###\s+(.+)$/gm, '<h3>$1</h3>');
    s = s.replace(/^\s*##\s+(.+)$/gm, '<h2>$1</h2>');
    s = s.replace(/^\s*#\s+(.+)$/gm, '<h1>$1</h1>');
    s = s.replace(/(^|\n)(?:[-*]\s.+)(?:\n[-*]\s.+)+/g, block => {
      const items = block.trim().split('\n').map(l => l.replace(/^[-*]\s+/, '')).map(t => `<li>${t}</li>`).join('');
      return `\n<ul>${items}</ul>`;
    });
    s = s.replace(/\n{2,}/g, '</p><p>');
    s = '<p>' + s.replace(/\n/g, '<br>') + '</p>';
    return s.replace(/<p><\/p>/g,'');
  }

  // Smooth scroll that eases in and out
function isNearBottom(px = 180){  // was 40; larger so auto-scroll keeps up
  return (messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight) < px;
}

let scrollAnimId = 0;
function smoothScrollToBottom(duration = 380){
  cancelAnimationFrame(scrollAnimId);
  const start = messagesEl.scrollTop;
  const end = messagesEl.scrollHeight - messagesEl.clientHeight;
  const t0 = performance.now();
  const easeInOutCubic = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
  function frame(now){
    const p = Math.min(1, (now - t0) / duration);
    messagesEl.scrollTop = start + (end - start) * easeInOutCubic(p);
    if (p < 1) scrollAnimId = requestAnimationFrame(frame);
  }
  scrollAnimId = requestAnimationFrame(frame);
}

  // Parse SSE "data: {...}" lines and pull any content-like field
function extractEventContent(line){
  try{
    const j = JSON.parse(line);
    return (
      j?.choices?.[0]?.delta?.content ??
      j?.choices?.[0]?.message?.content ??
      j?.delta?.content ?? j?.content ?? j?.text ?? j?.completion ?? ''
    );
  }catch{ return ''; }
}

// Stream from proxy. If upstream does not stream, the proxy may simulate SSE.
async function streamReply(model, historySoFar, typingBubble, sourcePrompt){
  const res = await fetch('/api/straico/chat', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ model, messages: historySoFar, stream:true })
  });
  if (!res.ok || !res.body) return null;

  // swap dots for real bubble
  const b = document.createElement('div'); b.className = 'bubble ai';
  const rich = document.createElement('div'); rich.className = 'rich'; b.appendChild(rich);
  const actions = document.createElement('div'); actions.className = 'actions';
  const copyBtn = document.createElement('button'); copyBtn.className = 'btn-mini'; copyBtn.textContent = 'Copy';
  const regenBtn= document.createElement('button'); regenBtn.className = 'btn-mini'; regenBtn.textContent = 'Regenerate';
  actions.appendChild(copyBtn); actions.appendChild(regenBtn); b.appendChild(actions);
  if (typingBubble) messagesEl.replaceChild(b, typingBubble); else messagesEl.appendChild(b);

  const reader = res.body.getReader();
  const decoder = new TextDecoder('utf-8');

  let buffer = '';
  let pending = '';     // not yet shown
  let revealed = '';    // already shown
  let doneReading = false;

  // stable typewriter that reveals at a constant rate
  const cps = 85;       // chars per second, smooth and quick
  let last = performance.now();
  let rafId;

  function tick(now){
    const dt = (now - last) / 1000; last = now;
    let take = Math.floor(cps * dt);
    if (pending.length && take < 1) take = 1;

    if (take > 0 && pending.length){
      const chunk = pending.slice(0, take);
      pending = pending.slice(take);
      revealed += chunk;
      rich.innerHTML = mdToHtml(revealed);
      // keep the view following the reveal while user is near the bottom
      if (isNearBottom()) smoothScrollToBottom(320);
    }
    if (!doneReading || pending.length){
      rafId = requestAnimationFrame(tick);
    } else {
      cancelAnimationFrame(rafId);
      history.push({ role:'assistant', content: revealed });
      copyBtn.onclick = () => { navigator.clipboard.writeText(rich.innerText || revealed); toast('Copied'); };
      regenBtn.onclick = () => regenerate(sourcePrompt, b);
    }
  }
  rafId = requestAnimationFrame(tick);

  while(true){
    const { value, done } = await reader.read();
    if (done){ doneReading = true; break; }
    buffer += decoder.decode(value, { stream:true });
    const parts = buffer.split(/\n\n/); buffer = parts.pop() || '';
    for (const block of parts){
      const line = block.replace(/^data:\s?/, '').trim();
      if (!line || line === '[DONE]') continue;
      const piece = extractEventContent(line);
      if (piece) pending += piece;
    }
  }

  if (!revealed && !pending) return null;
  return revealed || '';
}

  /* smooth sentence fade (opacity only) */
.rich .sentence{ transition: opacity .28s ease; }

  // Copy + Regenerate renderer (non-stream fallback)
  function showBotReply(reply, typingBubble, sourcePrompt){
    const b = document.createElement('div');
    b.className = 'bubble ai';
    const rich = document.createElement('div'); rich.className = 'rich';
    b.appendChild(rich);

    // actions
    const actions = document.createElement('div'); actions.className = 'actions';
    const copyBtn = document.createElement('button'); copyBtn.className = 'btn-mini'; copyBtn.textContent = 'Copy';
    const regenBtn= document.createElement('button'); regenBtn.className = 'btn-mini'; regenBtn.textContent = 'Regenerate';
    copyBtn.onclick = () => { navigator.clipboard.writeText(rich.innerText || String(reply)); toast('Copied'); };
    regenBtn.onclick = () => regenerate(sourcePrompt, b);
    actions.appendChild(copyBtn); actions.appendChild(regenBtn); b.appendChild(actions);

    if (typingBubble) messagesEl.replaceChild(b, typingBubble); else messagesEl.appendChild(b);

    rich.innerHTML = mdToHtml(String(reply));
    if (isNearBottom()) smoothScrollToBottom(400);

    history.push({ role:'assistant', content:String(reply) });
  }

// pull content from SSE lines
function extractEventContent(line){
  try{
    const j = JSON.parse(line);
    return (
      j?.choices?.[0]?.delta?.content ??
      j?.choices?.[0]?.message?.content ??
      j?.delta?.content ?? j?.content ?? j?.text ?? j?.completion ?? ''
    );
  }catch{ return ''; }
}

// tiny helper: append a sentence node with a gentle opacity fade
function appendSentence(rich, text){
  const span = document.createElement('div');
  span.className = 'sentence';
  span.style.opacity = '0';
  span.style.transition = 'opacity .28s ease';
  span.innerHTML = mdToHtml(text);
  rich.appendChild(span);
  requestAnimationFrame(()=>{ span.style.opacity = '1'; });
}

// streaming with sentence-by-sentence fade and pinned scroll
async function streamReply(model, historySoFar, typingBubble, sourcePrompt){
  const res = await fetch('/api/straico/chat', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ model, messages: historySoFar, stream:true })
  });
  if (!res.ok || !res.body) return null;

  // swap dots for a real bubble
  const b = document.createElement('div'); b.className = 'bubble ai';
  const rich = document.createElement('div'); rich.className = 'rich'; b.appendChild(rich);
  const actions = document.createElement('div'); actions.className = 'actions';
  const copyBtn = document.createElement('button'); copyBtn.className = 'btn-mini'; copyBtn.textContent = 'Copy';
  const regenBtn= document.createElement('button'); regenBtn.className = 'btn-mini'; regenBtn.textContent = 'Regenerate';
  actions.appendChild(copyBtn); actions.appendChild(regenBtn); b.appendChild(actions);
  if (typingBubble) messagesEl.replaceChild(b, typingBubble); else messagesEl.appendChild(b);

  const reader  = res.body.getReader();
  const decoder = new TextDecoder('utf-8');

  let bufferSSE = '';
  let working   = '';   // current unflushed text
  let fullText  = '';   // final text

  // live area for the current, not-yet-complete sentence
  let live = document.createElement('div');
  live.className = 'sentence';
  rich.appendChild(live);

  function flushCompleteSentences(){
    // find last end-of-sentence mark; keep any tail in 'working'
    const idx = working.lastIndexOf('.') > working.lastIndexOf('!') ? working.lastIndexOf('.') : working.lastIndexOf('!');
    const last = Math.max(idx, working.lastIndexOf('â€¦'), working.lastIndexOf('?'));
    if (last === -1) {
      // update the live span without fade
      live.innerHTML = mdToHtml(working);
      if (isNearBottom(160)) messagesEl.scrollTop = messagesEl.scrollHeight;
      return;
    }
    // split out the complete portion
    const complete = working.slice(0, last + 1);
    const remainder = working.slice(last + 1);

    // remove live, append the complete bit with fade, then create a new live
    rich.removeChild(live);
    appendSentence(rich, complete);
    fullText += complete;

    live = document.createElement('div');
    live.className = 'sentence';
    live.innerHTML = mdToHtml(remainder);
    rich.appendChild(live);

    working = remainder;
    if (isNearBottom(160)) messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  // animation-free pinning while text grows
  function pinScroll(){
    if (isNearBottom(160)) messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  while(true){
    const { value, done } = await reader.read();
    if (done) break;

    bufferSSE += decoder.decode(value, { stream:true });
    const parts = bufferSSE.split(/\n\n/); bufferSSE = parts.pop() || '';
    for (const block of parts){
      const line = block.replace(/^data:\s?/, '').trim();
      if (!line || line === '[DONE]') continue;
      const piece = extractEventContent(line);
      if (piece){
        working += piece;
        flushCompleteSentences();
        pinScroll();
      }
    }
  }

  // flush whatever remains
  if (working.trim()){
    rich.removeChild(live);
    appendSentence(rich, working);
    fullText += working;
  } else {
    // ensure live is removed if empty
    if (live && live.parentNode) live.parentNode.removeChild(live);
  }

  if (!fullText.trim()) return null;
  history.push({ role:'assistant', content: fullText });

  // wire actions
  copyBtn.onclick = () => { navigator.clipboard.writeText(rich.innerText || fullText); toast('Copied'); };
  regenBtn.onclick = () => regenerate(sourcePrompt, b);

  return fullText;
}


  // Load models from your secure endpoint
 async function loadModels(){
  try{
    const r = await fetch('/api/straico/models');
    const data = await r.json();
    const list = Array.isArray(data?.data) ? data.data : [];

    // group by provider (text before the slash)
    const groups = {};
    for (const m of list){
      if (!m?.model) continue;
      const prov = (m.model.split('/')[0] || 'Other').toLowerCase();
      (groups[prov] ||= []).push(m);
    }

    // order providers nicely
    const order = ['openai','anthropic','deepseek','google','meta-llama','mistralai','perplexity','qwen','nvidia','microsoft','amazon','x-ai'];
    const providers = Object.keys(groups).sort((a,b)=>{
      const ia = order.indexOf(a), ib = order.indexOf(b);
      return (ia === -1 && ib === -1) ? a.localeCompare(b) :
             (ia === -1) ? 1 : (ib === -1) ? -1 : ia - ib;
    });

    modelSel.innerHTML = '';
    for (const prov of providers){
      const og = document.createElement('optgroup');
      const label = prov.replace(/(^|[-])/g, s => s.toUpperCase()).replace(/-/g,' ');
      og.label = label;
      for (const m of groups[prov]){
        const o = document.createElement('option');
        o.value = m.model;
        o.textContent = m.name || m.model;
        og.appendChild(o);
      }
      modelSel.appendChild(og);
    }

    const preferred = ['openai/gpt-4o-mini','anthropic/claude-3.5-sonnet'];
    const found = preferred.find(p => [...modelSel.querySelectorAll('option')].some(o => o.value === p));
    modelSel.value = found || modelSel.querySelector('option')?.value || '';
  } catch {
    modelSel.innerHTML = '';
    const og = document.createElement('optgroup'); og.label = 'OpenAI';
    const o = document.createElement('option'); o.value = 'openai/gpt-4o-mini'; o.textContent = 'OpenAI: GPT-4o mini';
    og.appendChild(o); modelSel.appendChild(og);
  }
}

  // Send via proxy (stream first, fallback if needed)
  async function send(){
    const text = promptEl.value.trim();
    if (!text || !modelSel.value || sendBtn.disabled) return;

    promptEl.value = '';
    sendBtn.disabled = true;

    addUserBubble(text);
    const thinking = addTyping();

    try{
      const model = modelSel.value;

      // 1) streaming
      let got = null;
      try { got = await streamReply(model, history, thinking, text); } catch {}
      if (got !== null){ sendBtn.disabled = false; promptEl.focus(); return; }

      // 2) non-stream
      const r = await fetch('/api/straico/chat', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ model, messages: history, stream:false })
      });
      const raw = await r.text(); let data; try{ data = JSON.parse(raw);} catch{ data = { raw }; }
      if (!r.ok){
        thinking.remove();
        const err = data?.response?.error || data?.error || raw;
        showBotReply('Error ' + r.status + ': ' + err, null);
        return;
      }
      const reply =
        data?.choices?.[0]?.message?.content
        || data?.response?.completion?.choices?.[0]?.message?.content
        || data?.response?.text || 'No content returned.';
      showBotReply(reply, thinking, text);

    } catch {
      thinking.remove();
      showBotReply('Network error. Please try again.', null);
    } finally {
      sendBtn.disabled = false;
      promptEl.focus();
    }
  }

  // Events
  sendBtn.addEventListener('click', send);
  promptEl.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); send(); }});
  refreshBtn.addEventListener('click', () => { messagesEl.innerHTML=''; history.length=0; toast('New chat started'); });
  modelSel.addEventListener('change', () => {
    const label = modelSel.options[modelSel.selectedIndex]?.text || modelSel.value;
    toast('Model selected: ' + label);
    promptEl.focus();  // keep context, do not reset history
  });

  // Boot
  loadModels();
  promptEl.focus();
</script>
</body>
</html>
