<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ServeSmartAI</title>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#0f1115; --bg-2:#0c0f14;
    --panel:#141a22; --surface:#161d27;
    --ink:#e9edf3; --muted:#9aa6b2;
    --ring:#263447; --accent:#6aa6ff; --accent-2:#7b7bff;
    --bubble-user:#1f2735; --bubble-ai:#121923;
    --bubble-ai-bg:#121923; /* for typing bubble line below */
    --shadow:0 10px 30px rgba(0,0,0,.35), 0 1px 0 rgba(255,255,255,.02) inset;
  }

  *{ box-sizing:border-box }
  html, body{ height:100%; overflow:hidden }
  body{
    margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:var(--ink);
    background:
      radial-gradient(1400px 900px at 10% -10%, #25324a 0%, transparent 60%),
      radial-gradient(1000px 800px at 110% -10%, #1d2b45 0%, transparent 55%),
      linear-gradient(180deg, var(--bg), var(--bg-2));
  }

  /* layout */
  .wrap{
    height:100dvh; min-height:100svh;
    display:grid; grid-template-rows:auto 1fr auto;
    row-gap:18px;
    padding-top:16px;
  }
  header{
    backdrop-filter:saturate(150%) blur(8px);
    background:linear-gradient(180deg, rgba(26,34,45,.65), rgba(20,26,34,.65));
    border-bottom:1px solid var(--ring);
    padding:14px clamp(14px,2.5vw,22px);
    display:grid; grid-template-columns:1fr auto; gap:12px; align-items:center;
  }
  .brand{ display:flex; align-items:center; gap:10px }
  .logo{ width:28px; height:28px; border-radius:8px; background:linear-gradient(135deg,var(--accent),var(--accent-2)); box-shadow:0 8px 20px rgba(106,166,255,.35) }
  .title{ margin:0; font-weight:600; font-size:15px; letter-spacing:.2px; color:var(--ink); opacity:.95 }

  .controls{ display:flex; align-items:center; gap:10px }
  .select{
    appearance:none; background:var(--panel); color:var(--ink);
    border:1px solid var(--ring); border-radius:999px;
    padding:10px 40px 10px 14px; font:inherit; font-size:13px; box-shadow:var(--shadow)
  }
  .select:focus{ outline:2px solid var(--accent); outline-offset:2px }
  .chev{ pointer-events:none; margin-left:-34px; width:12px; opacity:.7 }
  .refresh{
    background:var(--panel); color:var(--ink); border:1px solid var(--ring); border-radius:999px;
    width:36px; height:36px; display:grid; place-items:center; margin-left:6px; cursor:pointer; box-shadow:var(--shadow)
  }
  .refresh:hover{ filter:brightness(1.1) }

  .panel{
    max-width:900px; width:100%;
    margin:0 auto;
    height:100%; min-height:0;
    display:grid; grid-template-rows:1fr auto;
    border:1px solid var(--ring); background:linear-gradient(180deg,#0f141c,#0e131a);
    border-radius:18px; box-shadow:0 20px 60px rgba(0,0,0,.45); overflow:hidden
  }

  .messages{
    position:relative;
    padding:clamp(14px,2.5vw,20px);
    padding-bottom:108px; /* keep clear of composer */
    scroll-padding-bottom:108px;
    height:100%; min-height:0; overflow:auto;
  }
  .messages::before{
    content:""; position:sticky; top:0; left:0; right:0; height:64px;
    background:linear-gradient(180deg, var(--bg), rgba(15,17,21,0));
    pointer-events:none; z-index:2;
  }

  .bubble{
    display:block;
    width:fit-content;
    max-width:min(76ch, calc(100% - 32px));
    border-radius:16px; padding:12px 14px; margin:10px 0; line-height:1.6;
    box-shadow:0 1px 0 rgba(255,255,255,.02) inset, 0 10px 24px rgba(0,0,0,.25)
  }
  .user{ background:var(--bubble-user); border:1px solid var(--ring); margin-left:auto }
  .ai{   background:var(--bubble-ai);   border:1px solid var(--ring); margin-right:auto }

  /* actions space on final AI bubbles */
  .bubble.ai{ position:relative; padding-bottom:34px }
  .actions{ position:absolute; left:12px; bottom:8px; display:flex; gap:6px; z-index:1 }
  .btn-mini{
    background:#0c1118; color:var(--ink);
    border:1px solid var(--ring); border-radius:8px;
    padding:4px 8px; font-size:11px; cursor:pointer; opacity:.85;
  }
  .btn-mini:hover{ opacity:1 }

  /* thinking bubble centring */
  .bubble.ai.typing{
    display:grid !important;
    place-items:center !important;
    height:34px; min-height:34px;
    line-height:0;
    padding:8px 12px !important;
    padding-bottom:8px !important;     /* cancel .bubble.ai bottom padding */
    position:static !important;
    background-color:var(--bubble-ai-bg);
    border-radius:12px;
  }
  .bubble.ai.typing .dots{
    display:flex; align-items:center; justify-content:center; gap:6px;
  }
  .bubble.ai.typing .dot{
    width:6px; height:6px; border-radius:50%;
    background:var(--muted); opacity:.35; animation:blink 1.2s infinite ease-in-out;
  }
  .bubble.ai.typing .dot:nth-child(2){ animation-delay:.2s }
  .bubble.ai.typing .dot:nth-child(3){ animation-delay:.4s }
  @keyframes blink{ 0%,80%,100%{opacity:.25; transform:translateY(0)} 40%{opacity:1; transform:translateY(-2px)} }

  /* markdown look */
  .rich h1,.rich h2,.rich h3{ margin:8px 0 6px }
  .rich h1{ font-size:20px } .rich h2{ font-size:18px } .rich h3{ font-size:16px }
  .rich code{ background:#0c1118; border:1px solid var(--ring); padding:2px 6px; border-radius:6px; font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:.95em }
  .rich pre{ background:#0c1118; border:1px solid var(--ring); padding:10px; border-radius:10px; overflow:auto }
  .rich ul{ padding-left:18px; margin:6px 0 } .rich li{ margin:2px 0 }
  .rich .sentence{ transition: opacity .28s ease; }

  .composer{ border-top:1px solid var(--ring); display:grid; grid-template-columns:1fr auto; gap:10px; padding:12px; background:linear-gradient(180deg,#0e131a,#0c1118) }
  .input{ background:var(--surface); color:var(--ink); border:1px solid var(--ring); border-radius:12px; padding:14px 16px; font:inherit; font-size:14px; box-shadow:var(--shadow) }
  .input::placeholder{ color:var(--muted) }
  .send{ background:linear-gradient(180deg,var(--accent),#4b86ff); color:#0b1220; border:none; border-radius:12px; padding:12px 18px; font:inherit; font-weight:600; cursor:pointer; box-shadow:0 12px 30px rgba(106,166,255,.35) }
  .send:disabled{ opacity:.6; cursor:default }

  .toast{
    position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
    background:rgba(20,26,34,.9); color:var(--ink); border:1px solid var(--ring);
    padding:8px 12px; border-radius:10px; font-size:12px; opacity:0; transition:opacity .2s; z-index:9999
  }
  .toast.show{ opacity:1 }

  footer{ opacity:.55; font-size:12px; text-align:center; padding:18px 10px 28px }

  @media (max-width:560px){ .panel{ border-radius:0 } .messages{ padding-bottom:8px } }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <h1 class="title">ServeSmartAI</h1>
    </div>

    <div class="controls" title="Choose a model">
      <select id="model" class="select"></select>
      <svg class="chev" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path d="M3 4.5l3 3 3-3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
      </svg>
      <button id="refresh" class="refresh" title="New chat">
        <svg viewBox="0 0 24 24" width="16" height="16" aria-hidden="true">
          <path d="M23 4v6h-6M1 20v-6h6" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>
          <path d="M3.5 9A9 9 0 0 1 18.3 5.6L23 10M1 14l4.7 4.4A9 9 0 0 0 20.5 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>
        </svg>
      </button>
    </div>
  </header>

  <main class="panel">
    <div id="messages" class="messages"></div>
    <div class="composer">
      <input id="prompt" class="input" placeholder="Write your message" autocomplete="off" />
      <button id="send" class="send">Send</button>
    </div>
  </main>

  <footer>Built by ServeSmartAI</footer>
</div>

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
  // Elements
  const modelSel  = document.getElementById('model');
  const messagesEl= document.getElementById('messages');
  const promptEl  = document.getElementById('prompt');
  const sendBtn   = document.getElementById('send');
  const refreshBtn= document.getElementById('refresh');
  const toastEl   = document.getElementById('toast');

  // Conversation memory
  const history = [];

  // UI helpers
  function addUserBubble(text){
    const b = document.createElement('div');
    b.className = 'bubble user';
    b.textContent = text;
    messagesEl.appendChild(b);
    messagesEl.scrollTop = messagesEl.scrollHeight;
    history.push({ role:'user', content:text });
  }

  function addTyping() {
    const b = document.createElement("div");
    b.className = "bubble ai typing";
    b.innerHTML = `
      <div class="dots">
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
      </div>`;
    messagesEl.appendChild(b);
    messagesEl.scrollTop = messagesEl.scrollHeight;
    return b;
  }

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 1600);
  }

  // Basic markdown
  function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function mdToHtml(input){
    let s = escapeHtml(input);
    s = s.replace(/```([\s\S]*?)```/g, (_m,c)=>`<pre><code>${c}</code></pre>`);
    s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
    s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    s = s.replace(/(^|[^*])\*(?!\s)([^*]+?)\*(?!\*)/g, '$1<em>$2</em>');
    s = s.replace(/^\s*###\s+(.+)$/gm, '<h3>$1</h3>');
    s = s.replace(/^\s*##\s+(.+)$/gm, '<h2>$1</h2>');
    s = s.replace(/^\s*#\s+(.+)$/gm, '<h1>$1</h1>');
    s = s.replace(/(^|\n)(?:[-*]\s.+)(?:\n[-*]\s.+)+/g, block => {
      const items = block.trim().split('\n').map(l => l.replace(/^[-*]\s+/, '')).map(t => `<li>${t}</li>`).join('');
      return `\n<ul>${items}</ul>`;
    });
    s = s.replace(/\n{2,}/g, '</p><p>');
    s = '<p>' + s.replace(/\n/g, '<br>') + '</p>';
    return s.replace(/<p><\/p>/g,'');
  }

  // Smooth scroll helpers
  function isNearBottom(px = 180){
    return (messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight) < px;
  }
  let scrollAnimId = 0;
  function smoothScrollToBottom(duration = 380){
    cancelAnimationFrame(scrollAnimId);
    const start = messagesEl.scrollTop;
    const end = messagesEl.scrollHeight - messagesEl.clientHeight;
    const t0 = performance.now();
    const easeInOutCubic = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
    function frame(now){
      const p = Math.min(1, (now - t0) / duration);
      messagesEl.scrollTop = start + (end - start) * easeInOutCubic(p);
      if (p < 1) scrollAnimId = requestAnimationFrame(frame);
    }
    scrollAnimId = requestAnimationFrame(frame);
  }

  // SSE parsing
  function extractEventContent(line){
    try{
      const j = JSON.parse(line);
      return (
        j?.choices?.[0]?.delta?.content ??
        j?.choices?.[0]?.message?.content ??
        j?.delta?.content ?? j?.content ?? j?.text ?? j?.completion ?? ''
      );
    }catch{ return ''; }
  }

  // Non-stream fallback
  function showBotReply(reply, typingBubble, sourcePrompt){
    const b = document.createElement('div');
    b.className = 'bubble ai';
    const rich = document.createElement('div'); rich.className = 'rich';
    b.appendChild(rich);

    // actions
    const actions = document.createElement('div'); actions.className = 'actions';
    const copyBtn = document.createElement('button'); copyBtn.className = 'btn-mini'; copyBtn.textContent = 'Copy';
    const regenBtn= document.createElement('button'); regenBtn.className = 'btn-mini'; regenBtn.textContent = 'Regenerate';
    copyBtn.onclick = () => { navigator.clipboard.writeText(rich.innerText || String(reply)); toast('Copied'); };
    regenBtn.onclick = () => regenerate(sourcePrompt, b);
    actions.appendChild(copyBtn); actions.appendChild(regenBtn); b.appendChild(actions);

    if (typingBubble) messagesEl.replaceChild(b, typingBubble); else messagesEl.appendChild(b);

    rich.innerHTML = mdToHtml(String(reply));
    if (isNearBottom()) smoothScrollToBottom(400);

    history.push({ role:'assistant', content:String(reply) });
  }

  // Streaming with sentence fade and pinned scroll
  function appendSentence(rich, text){
    const span = document.createElement('div');
    span.className = 'sentence';
    span.style.opacity = '0';
    span.style.transition = 'opacity .28s ease';
    span.innerHTML = mdToHtml(text);
    rich.appendChild(span);
    requestAnimationFrame(()=>{ span.style.opacity = '1'; });
  }

  async function streamReply(model, historySoFar, typingBubble, sourcePrompt){
    const res = await fetch('/api/straico/chat', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ model, messages: historySoFar, stream:true })
    });
    if (!res.ok || !res.body) return null;

    // swap dots for real bubble
    const b = document.createElement('div'); b.className = 'bubble ai';
    const rich = document.createElement('div'); rich.className = 'rich'; b.appendChild(rich);
    const actions = document.createElement('div'); actions.className = 'actions';
    const copyBtn = document.createElement('button'); copyBtn.className = 'btn-mini'; copyBtn.textContent = 'Copy';
    const regenBtn= document.createElement('button'); regenBtn.className = 'btn-mini'; regenBtn.textContent = 'Regenerate';
    actions.appendChild(copyBtn); actions.appendChild(regenBtn); b.appendChild(actions);
    if (typingBubble) messagesEl.replaceChild(b, typingBubble); else messagesEl.appendChild(b);

    const reader  = res.body.getReader();
    const decoder = new TextDecoder('utf-8');

    let bufferSSE = '';
    let working   = '';
    let fullText  = '';

    // live line
    let live = document.createElement('div');
    live.className = 'sentence';
    rich.appendChild(live);

    function flushComplete(){
      const idxDot = working.lastIndexOf('.');
      const idxExc = working.lastIndexOf('!');
      const idxQue = working.lastIndexOf('?');
      const idxEll = working.lastIndexOf('â€¦');
      const last = Math.max(idxDot, idxExc, idxQue, idxEll);
      if (last === -1){
        live.innerHTML = mdToHtml(working);
        if (isNearBottom(160)) messagesEl.scrollTop = messagesEl.scrollHeight;
        return;
      }
      const complete = working.slice(0, last + 1);
      const remainder= working.slice(last + 1);

      rich.removeChild(live);
      appendSentence(rich, complete);
      fullText += complete;

      live = document.createElement('div');
      live.className = 'sentence';
      live.innerHTML = mdToHtml(remainder);
      rich.appendChild(live);

      working = remainder;
      if (isNearBottom(160)) messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    while(true){
      const { value, done } = await reader.read();
      if (done) break;
      bufferSSE += decoder.decode(value, { stream:true });
      const parts = bufferSSE.split(/\n\n/); bufferSSE = parts.pop() || '';
      for (const block of parts){
        const line = block.replace(/^data:\s?/, '').trim();
        if (!line || line === '[DONE]') continue;
        const piece = extractEventContent(line);
        if (piece){
          working += piece;
          flushComplete();
          if (isNearBottom(160)) messagesEl.scrollTop = messagesEl.scrollHeight;
        }
      }
    }

    // flush remainder
    if (working.trim()){
      rich.removeChild(live);
      appendSentence(rich, working);
      fullText += working;
    } else if (live && live.parentNode){
      live.parentNode.removeChild(live);
    }

    if (!fullText.trim()) return null;
    history.push({ role:'assistant', content: fullText });
    copyBtn.onclick = () => { navigator.clipboard.writeText(rich.innerText || fullText); toast('Copied'); };
    regenBtn.onclick = () => regenerate(sourcePrompt, b);
    return fullText;
  }

  // Regenerate last assistant using same user prompt
  async function regenerate(promptText, oldBubble){
    if (!promptText || !oldBubble) return;
    for (let i = history.length - 1; i >= 0; i--) {
      if (history[i].role === 'assistant') { history.splice(i, 1); break; }
    }
    const t = addTyping();
    messagesEl.insertBefore(t, oldBubble);
    oldBubble.remove();

    const model = modelSel.value;
    let got = null;
    try { got = await streamReply(model, history, t, promptText); } catch {}
    if (got !== null) return;

    try{
      const r = await fetch('/api/straico/chat', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ model, messages: history, stream:false })
      });
      const raw = await r.text(); let data; try{ data = JSON.parse(raw);} catch{ data = { raw }; }
      if (!r.ok){ t.remove(); showBotReply('Error ' + r.status + ': ' + (data?.response?.error || data?.error || raw), null); return; }
      const reply =
        data?.choices?.[0]?.message?.content
        || data?.response?.completion?.choices?.[0]?.message?.content
        || data?.response?.text || 'No content returned.';
      showBotReply(reply, t, promptText);
    } catch { t.remove(); showBotReply('Network error. Please try again.', null); }
  }

  // Grouped model loader
  async function loadModels(){
    try{
      const r = await fetch('/api/straico/models');
      const data = await r.json();
      const list = Array.isArray(data?.data) ? data.data : [];

      const groups = {};
      for (const m of list){
        if (!m?.model) continue;
        const prov = (m.model.split('/')[0] || 'Other').toLowerCase();
        (groups[prov] ||= []).push(m);
      }
      const order = ['openai','anthropic','deepseek','google','meta-llama','mistralai','perplexity','qwen','nvidia','microsoft','amazon','x-ai'];
      const providers = Object.keys(groups).sort((a,b)=>{
        const ia = order.indexOf(a), ib = order.indexOf(b);
        return (ia === -1 && ib === -1) ? a.localeCompare(b) :
               (ia === -1) ? 1 : (ib === -1) ? -1 : ia - ib;
      });

      modelSel.innerHTML = '';
      for (const prov of providers){
        const og = document.createElement('optgroup');
        const label = prov.replace(/(^|[-])/g, s => s.toUpperCase()).replace(/-/g,' ');
        og.label = label;
        for (const m of groups[prov]){
          const o = document.createElement('option');
          o.value = m.model; o.textContent = m.name || m.model;
          og.appendChild(o);
        }
        modelSel.appendChild(og);
      }
      const preferred = ['openai/gpt-4o-mini','anthropic/claude-3.5-sonnet'];
      const found = preferred.find(p => [...modelSel.querySelectorAll('option')].some(o => o.value === p));
      modelSel.value = found || modelSel.querySelector('option')?.value || '';
    } catch {
      modelSel.innerHTML = '';
      const og = document.createElement('optgroup'); og.label = 'OpenAI';
      const o = document.createElement('option'); o.value = 'openai/gpt-4o-mini'; o.textContent = 'OpenAI: GPT-4o mini';
      og.appendChild(o); modelSel.appendChild(og);
    }
  }

  // Send
  async function send(){
    const text = promptEl.value.trim();
    if (!text || !modelSel.value || sendBtn.disabled) return;

    promptEl.value = '';
    sendBtn.disabled = true;

    addUserBubble(text);
    const thinking = addTyping();

    try{
      const model = modelSel.value;
      let got = null;
      try { got = await streamReply(model, history, thinking, text); } catch {}
      if (got !== null){ sendBtn.disabled = false; promptEl.focus(); return; }

      const r = await fetch('/api/straico/chat', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ model, messages: history, stream:false })
      });
      const raw = await r.text(); let data; try{ data = JSON.parse(raw);} catch{ data = { raw }; }
      if (!r.ok){
        thinking.remove();
        const err = data?.response?.error || data?.error || raw;
        showBotReply('Error ' + r.status + ': ' + err, null);
        return;
      }
      const reply =
        data?.choices?.[0]?.message?.content
        || data?.response?.completion?.choices?.[0]?.message?.content
        || data?.response?.text || 'No content returned.';
      showBotReply(reply, thinking, text);
    } catch {
      thinking.remove();
      showBotReply('Network error. Please try again.', null);
    } finally {
      sendBtn.disabled = false;
      promptEl.focus();
    }
  }

  // Events
  sendBtn.addEventListener('click', send);
  promptEl.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); send(); }});
  refreshBtn.addEventListener('click', () => { messagesEl.innerHTML=''; history.length=0; toast('New chat started'); });
  modelSel.addEventListener('change', () => {
    const label = modelSel.options[modelSel.selectedIndex]?.text || modelSel.value;
    toast('Model selected: ' + label);
    promptEl.focus();
  });

  // Boot
  loadModels();
  promptEl.focus();
</script>
</body>
</html>
